package.path=package.path..";../Samples/ysscripts/lib/?.lua" --;"..package.path
require("utilfunc")

useCases.gait_muscle={
	--endSegW = 10,
	--prec = .1,

	k_p_ID=120,
	k_d_ID=2.*math.sqrt(120),
	--k_p_ID=20,
	--k_d_ID=2.*math.sqrt(20),
	--ddqObjWeight=10000000,

	--actuationType = ActuationType.tau,
	--actuationType = ActuationType.ft,
	actuationType = ActuationType.a,
	--actuationType = ActuationType.u,

	--tauObjWeight=1,
	--ftObjWeight=1,
	--aObjWeight=100000000,
	--lambdaObjWeight=100,
	----lambdaObjWeight=10,

	----EEobjWeight=60000000, 
	--EEobjWeight=100000000, 
	--EEobjWeightAngular=60000000, 
	--momentumWeight=8000000, 

	excludeRoot = true,

	tauMax = 400,
	ftMax = 4000,

	initMsclForceScale=1,

	invFricCoef=.5,
	invAccConeCoef=.1,
	contactMargin=.001,
	velMarginStrength=1,
	maxPenetratingVel=0,

	scenario=scenarios.ETC, 
	modelName='gait_muscle',
	useAnalyticIK=true, 
	grpName='gait_muscle',
	grpNames={'gait_muscle'},
	useFootEncodingMethod2=
	{
		true,
		geom={
			L={ 
				--{"LeftFoot", vector3(0,-0.03,0.02)},
				--{"LeftToes", vector3(0,-0.03,0.02)},
				{"ankle_l", vector3(-.05,-.05,.0)},
				{"ankle_l", vector3(.1,-.05,.0)},
			},
			R={
				--{"RightFoot", vector3(0,-0.03,0.02)},
				--{"RightToes", vector3(0,-0.03,0.02)},
				{"ankle_r", vector3(-.05,-.05,.0)},
				{"ankle_r", vector3(.1,-.05,.0)},
			},
		}
	},
	lfootpos=vector3(.1,-.05,.0),
	rfootpos=vector3(.1,-.05,.0),
	useQPsolver=true,
	footPosFeedbackMethod=2,
	useMomentumPreservingIK=false,
	--mot_file=package.resourcePath.."woody/woody.dof",
	--mot_file=package.resourcePath.."opensim/gait19_6steps_120.dof",
	--mot_file_upsample=4,
	mot_file_upsample=1,
	desiredPos=vector3(0,0,0),

	--measureOptCost=useCases.measureOptCost,
	-- [[[[  이 괄호 사이 부분은 맨 처음에는 필요없음
	-- the initial pendControlParam and pendOptimizationPath can be automatically generated by using createInitialPendControlParam.lua
	
		-- the initial pendControlParam and pendOptimizationPath can be automatically generated by using createInitialPendControlParam.lua
	pendControlParam={['keyframe,0,pendDesiredVel,gait_muscle,l,z']=0,['keyframe,0,pendDesiredVel,gait_muscle,l,x']=1,['keyframe,0,pendDesiredVel,gait_muscle,r,z']=0,['keyframe,0,pendDesiredVel,gait_muscle,r,x']=1,['keyframe,0,pendDesiredVel,gait_muscle,L1,z']=0,['keyframe,0,pendDesiredVel,gait_muscle,L1,x']=1,['keyframe,0,pendDesiredVel,gait_muscle,R1,z']=0,['keyframe,0,pendDesiredVel,gait_muscle,R1,x']=1,['keyframe,0,pendDesiredVel,gait_muscle,L2,z']=0,['keyframe,0,pendDesiredVel,gait_muscle,L2,x']=1,['keyframe,0,pendDesiredVel,ignore,0,z']=0,['keyframe,0,pendDesiredVel,ignore,0,x']=1,['keyframe,0,pendDesiredVel,ignore,1,z']=0,['keyframe,0,pendDesiredVel,ignore,1,x']=1,
},
	pendOptimizationPath=
{
	firstFrames={1,10,80,157,227,301,373,447,},
	segments={'ignore,0','gait_muscle,l','gait_muscle,r','gait_muscle,L1','gait_muscle,R1','gait_muscle,L2','ignore,1'},
},
	--
	conservativePrediction=1.0,
	muscleActiveness=0.8,
	keyframes={
		pendDesiredVel={numKey=1, default=vector3(1,0,0)},
		swingFootForce={numKey=3, default=vector3(0,10,0)},
		footLmod={numKey=3, numKeyFrom='key', default=vector3(0,0,0)},
		footRmod={numKey=3, numKeyFrom='key', default=vector3(0,0,0)},
		footLmocapMod={numKey=3, numKeyFrom='key', default=vector3(0,0,0)},
		footRmocapMod={numKey=3, numKeyFrom='key', default=vector3(0,0,0)},
		desiredHeadAcc={numKey=3, numKeyFrom='key', default=vector3(0,0,0)},
		desiredMomentum={numKey=3, numKeyFrom='key', default=vector3(0,0,0)},
		desiredDotMomentum={numKey=3, numKeyFrom='key', isContinuous=false,default=vector3(0,0,0)},
		desiredLeaning={numKey=1, isContinuous=false,default=vector3(0,0,0)},
		spprtImpL={numKey=2, default=1},
		spprtImpR={numKey=2, default=1},
		mocapCompensationCoef={numKey=1, default=vector3(1, 1.0, 1)},
	},
	segProperties={
		noCOPcontrol={default=false}
	},

}
	
useCases.gait_muscle.mirrorAxis = {ang = {"y", "z"}, pos = {"z"}, all = true, non = false}

useCases.gait_muscle.optParamNames = {"MAPswingFootMod","MAPspprtFootMod"}
useCases.gait_muscle.parts = {"Foot"}
useCases.gait_muscle.partProps = {Foot = "pos"}
useCases.gait_muscle.partScales = {}

--optParam = makeOptParam(3,"MAPswingFootMod,"..grpName,"MAPspprtFootMod,"..grpName)
	--optParam = makeOptParam(3,"MAPswingHipMod,"..grpName,"MAPspprtHipMod,"..grpName, "MAP1swingKneeMod,"..grpName, "MAP1spprtKneeMod,"..grpName, "MAPswingAnkleMod,"..grpName, "MAPspprtAnkleMod,"..grpName, "MAP1swingMtpMod,"..grpName,"MAP1spprtMtpMod,"..grpName)
	--optParam = makeOptParam(3,"MAPswingFootMod,"..grpName,"MAPspprtFootMod,"..grpName, "MAPswingFootangleMod,"..grpName, "MAPspprtFootangleMod,"..grpName)

	
useCases.gait_muscle.attachCamera=true

function useCases.gait_muscle:makeScalarKeyframe(name, isDiscrete)
	if isDiscrete then
		self.keyframes[name] = {numKey=1, numKeyFrom='key', isContinuous = false, default = 0, valueType='scalar'}
	else
		self.keyframes[name] = {numKey=1, numKeyFrom='key', default = 0, valueType='scalar'}
	end
end

function useCases.gait_muscle:makeVec3Keyframe(name)
	print(self.keyframes)
	self.keyframes[name]={numKey=3, numKeyFrom='key', default=vector3(0,0,0)}
end

function useCases.gait_muscle:makeAsymmetricParams()

	local phaseNames = {"swing", "spprt"}
	local asym = "Asym"

	local asymOptParamNames = {}
	for i,v in ipairs(self.optParamNames) do
		local sIdx, eIdx
		for _,sv in ipairs(phaseNames) do
			sTempIdx, eTempIdx = string.find(v, sv)
			if sTempIdx~=nil then
				sIdx = sTempIdx
				eIdx = eTempIdx
				break
			end
		end
		table.insert(asymOptParamNames, string.sub(v,1,eIdx)..asym..string.sub(v, eIdx+1))
	end
	self.optParamNames = concat_array(self.optParamNames, asymOptParamNames)

	local asymParts = {}
	for i,v in ipairs(self.parts) do
		table.insert(asymParts, asym..v)
		if self.keyframes[string.lower(v).."Lmod"]["numKey"] == 3 then
			print(self.keyframes)
			self:makeVec3Keyframe(string.lower(asym..v).."Lmod")
			self:makeVec3Keyframe(string.lower(asym..v).."Rmod")
		else
			if self.keyframes[string.lower(v).."Lmod"]["isContinuous"] == false then
				self:makeScalarKeyframe(string.lower(asym..v).."Lmod", true)
				self:makeScalarKeyframe(string.lower(asym..v).."Rmod", true)
			else
				self:makeScalarKeyframe(string.lower(asym..v).."Lmod")
				self:makeScalarKeyframe(string.lower(asym..v).."Rmod")
			end
		end
	end
	self.parts = concat_array(asymParts, self.parts)

	local asymPartProps = {}
	for i,v in pairs(self.partProps) do
		asymPartProps[asym..i] = v
	end
	for i,v in pairs(asymPartProps) do
		self.partProps[i] = v
	end

	local asymPartScales = {}
	for i,v in pairs(self.partScales) do
		asymPartScales[asym..i] = v
	end
	for i,v in pairs(asymPartScales) do
		self.partScales[i] = v
	end

	--printtbl(self.optParamNames)
	--printtbl(self.parts)
	--printtbl(self.partProps)
	--printtbl(self.partScales)
	--printtbl(self.keyframes)

end


function useCases.gait_muscle:makeOptParam(numKey,...)
	local gtarget=array:new()
	local prec=self.prec
	for iid,id in ipairs({...}) do
		for i=0, numKey-1 do
			--dcjo
			if string.sub(id,1,5)=="MAPD1" then
				if i==0 then
					gtarget:pushBack({"map,"..i..","..string.sub(id,6),prec})
				end
			elseif string.sub(id,1,4)=="MAP1" then
				gtarget:pushBack({"map,"..i..","..string.sub(id,5),prec})
			elseif string.sub(id,1,3)=="MAP" then
				gtarget:pushBack({"map,"..i..","..string.sub(id,4)..",x",prec})
				gtarget:pushBack({"map,"..i..","..string.sub(id,4)..",y",prec})
				gtarget:pushBack({"map,"..i..","..string.sub(id,4)..",z",prec})
			else
				gtarget:pushBack({"keyframe,"..i..","..id..",x",prec})
				gtarget:pushBack({"keyframe,"..i..","..id..",y",prec})
				gtarget:pushBack({"keyframe,"..i..","..id..",z",prec})
			end
		end
	end
	return gtarget
end
function useCases.gait_muscle:makeOptParamAxis(numKey,axis,...)
	-- todo
--[[
	local gtarget=array:new()
	--local prec=0.05
	local prec=self.prec
	local symmetricMapUsed=false
	for iid,id in ipairs({...}) do
		for i=0, numKey-1 do
			if string.sub(id,1,3)=="MAP" then
				gtarget:pushBack({"map,"..i..","..string.sub(id,4)..","..axis,prec})
				--symmetricMapUsed=true
			else
				gtarget:pushBack({"keyframe,"..i..","..id..","..axis,prec})
			end
		end
	end
	return gtarget
	]]
end

function useCases.gait_muscle:updateStageParam(stage, stageParam)
	
	gains={}
	local endSegW=self.endSegW
	local grpName=self.grpName
	local genOpt=function(starts, ends, ps, pe, name, axis, others)
		local out=useCases.genOpt(useCase, starts, ends, ps, pe, name, axis,others, grpName, path)
		assert(out)
		return out
	end
--	local tgt_all={'footLmod','footRmod'}
--	local tgt_L={'footLmod', }
--	local tgt_R={'footRmod', }

	local optParamFullNames = {}
	for i, pName in ipairs(self.optParamNames) do
		optParamFullNames[i] = pName..","..grpName
	end

	local optParam = self:makeOptParam(3, unpack(optParamFullNames))

	do
		-- dcjo
		-- optimize walk cycles (assuming symmetry)
		--local endSegW=stage+23
		local mod=math.mod(stage-1,4)
		if mod==0 then
			stageParam[stage]={startSeg=1, endSeg=endSegW, nvar=2,setStageFunc="setStage_param", param=optParam, objCost=objCost,baseStage=1}
			--stageParam[stage]={startSeg=1, endSeg=endSegW, nvar=2,setStageFunc="setStage_param", param=self:makeOptParam(3,"MAPswingFootMod,"..grpName,"MAPspprtFootMod,"..grpName), objCost=objCost,baseStage=1}
			--stageParam[stage]={startSeg=1, endSeg=endSegW, nvar=2,setStageFunc="setStage_param", param=self:makeOptParam(3,"MAPswingHipMod,"..grpName,"MAPspprtHipMod,"..grpName, "MAP1swingKneeMod,"..grpName, "MAP1spprtKneeMod,"..grpName, "MAPswingAnkleMod,"..grpName, "MAPspprtAnkleMod,"..grpName, "MAP1swingMtpMod,"..grpName,"MAP1spprtMtpMod,"..grpName), objCost=objCost,baseStage=1}
			--stageParam[stage]={startSeg=1, endSeg=endSegW, nvar=2,setStageFunc="setStage_param", param=self:makeOptParam(3,"MAPswingFootMod,"..grpName,"MAPspprtFootMod,"..grpName, "MAPswingFootangleMod,"..grpName, "MAPspprtFootangleMod,"..grpName), objCost=objCost,baseStage=1}
		elseif mod==1 then
			stageParam[stage]={startSeg=1, endSeg=endSegW, nvar=2,setStageFunc="setStage_param", param=self:makeOptParamAxis(3,'z',"MAPswingFootMod,"..grpName,"MAPspprtFootMod,"..grpName), objCost=objCost,baseStage=1}
		elseif mod==2 then
			stageParam[stage]={startSeg=1, endSeg=endSegW, nvar=2,setStageFunc="setStage_param", param=self:makeOptParamAxis(3,'x',"MAPswingFootMod,"..grpName,"MAPspprtFootMod,"..grpName), objCost=objCost,baseStage=1}
		elseif mod==3 then
			stageParam[stage]={startSeg=1, endSeg=endSegW, nvar=2,setStageFunc="setStage_param", param=self:makeOptParamAxis(3,'y',"MAPswingFootMod,"..grpName,"MAPspprtFootMod,"..grpName), objCost=objCost,baseStage=1}
		end
		--dbg.console()
	end
	--stageParam[stage+1]={baseStage=1, startSeg=1}
end

function  useCases.gait_muscle:genStageParamInitial()
	local stageParam={}
	self:updateStageParam(1, stageParam)
	return stageParam
end

useCases.gait_muscle.mapControlParam=function(graph, title, param, useCase)
	
	local out={}

	assert(string.sub(title, 1,4)=="map,")
	local tokens=string.tokenize(title,',')
	local idx=tonumber(tokens[2])
	local name=tokens[3]

	local convertMap=function(name, mirror)
		-- dcjo
		local sIdx, eIdx, sTempIdx, eTempIdx;
		local parts = useCase.parts
		--local parts={"Foot"}
		--local parts={"Footangle", "Foot"}
		--local parts={"Hip", "Knee", "Ankle", "Mtp"}
		local key, id, part
--[[
		for i,v in ipairs(parts) do
			sTempIdx, eTempIdx = string.find(name, v)
			if sTempIdx~=nil then
				sIdx = sTempIdx
				eIdx = eTempIdx
				part = v
				break
			end
		end
		assert(sIdx)
		key=string.sub(name, 1, sIdx-1)
		id=string.lower(string.sub(name, eIdx+1))
		]]
		local phaseNames = {'swing', 'spprt'}
		for _,v in ipairs(phaseNames) do
			sTempIdx, eTempIdx = string.find(name, v)
			if sTempIdx~=nil then
				sIdx = sTempIdx
				eIdx = eTempIdx
				part = v
				break
			end
		end
		assert(sIdx)
		key = string.sub(name, 1, eIdx)
		id = "Mod"
		sTempIdx = string.find(name, id)
		assert(sTempIdx)
		part = string.sub(name, eIdx+1, sTempIdx-1)

--		id=string.lower(string.sub(name, Idx[2]+1, Idx[2]+1))..string.sub(name, Idx[2]+2)
--		local FootIdx=string.find(name, "Foot")
--		local key=string.sub(name, 1, FootIdx+3)
--		local id=string.lower(string.sub(name, FootIdx+4, FootIdx+4))..string.sub(name, FootIdx+5)
		local convertMap

		local firstFoot = useCases[tokens[4]].segNames[1]

		if mirror then
			if firstFoot == 'l' then
				convertMap=
				{
					swing={'R', ',L'}, 
					spprt={'L', ',L'},
					body ={'', ',L'},
				}
			else
				convertMap=
				{
					swing={'L', ',R'}, 
					spprt={'R', ',R'},
					body ={'', ',R'},
				}
			end
		else
			if firstFoot == 'l' then
				convertMap=
				{
					swing={'L', ',R1'}, 
					spprt={'R', ',R1'},
					body ={'', ',R1'},
				}
			else
				convertMap=
				{
					swing={'R', ',L1'}, 
					spprt={'L', ',L1'},
					body ={'', ',L1'},
				}
			end
		end
		return {","..string.lower(part)..convertMap[key][1]..string.lower(id)..",", convertMap[key][2],}, part
	end

	local grp=tokens[4]
	local axis=tokens[5]
	local cmap, part =convertMap(name)
	local cmapm=convertMap(name,true)
	local name2='keyframe,'..idx..cmap[1]..grp..cmap[2]
	local name2_mirror='keyframe,'..idx..cmapm[1]..grp..cmapm[2]

	--print(title)
	--print(name2)
	--print(name2_mirror)
	
	local mirAxis = useCase.mirrorAxis[useCase.partProps[part]]

	if axis~= nil then
		
		array.pushBack(out, {name2..","..axis,param}) 

		if table.member(axis, mirAxis) then
			array.pushBack(out, {name2_mirror..","..axis,param*-1}) 
		else
			array.pushBack(out, {name2_mirror..","..axis,param}) 
		end

	else
		array.pushBack(out, {name2, param})
		
		if mirAxis then
			array.pushBack(out, {name2_mirror, param*-1})
		else
			array.pushBack(out, {name2_mirror, param})
		end

	end

	--[[
	if axis~=nil then
		array.pushBack(out, {name2..","..axis,param}) 

		if axis=='y' or axis=='z' then
			array.pushBack(out, {name2_mirror..","..axis,param*-1}) 
		else
			array.pushBack(out, {name2_mirror..","..axis,param}) 
		end
	else
		array.pushBack(out, {name2, param})
		array.pushBack(out, {name2_mirror, param})
--		local param2=param:copy()
--		array.pushBack(out, {name2, param2})
--		param2.x=param2.x*-1
--		array.pushBack(out, {name2_mirror, param2})
	end
]]


	return out

end

useCases.gait_muscle.funcUpdateConstraints=function(graph)
	useCases.defaultFuncUpdateConstraints(useCase, graph)
end

useCases.gait_muscle.registerContactPair=function(model, loader, floor, simulator)

	param=vectorn ()
	param:setValues(0.5,0.5, model.penaltyForceStiffness, model.penaltyForceDamp)
	for i=1,loader:numBone()-1 do

		local bone_i=loader:VRMLbone(i)
		if string.find(bone_i:name(), "Foot")
			or string.find(bone_i:name(), "Toe") then
			simulator:registerCollisionCheckPair(loader:name(),bone_i.NameId, floor:name(), floor:bone(1):name(), param)
		end
	end
end


useCases.gait_muscle.init_globals=function()
	outputSuperSample=1
	PDservoLatency=5-- for debugging. set 5 for normal use.
	IDservoLatency=0
	PredictionLatency=0
	model.simulationFrameRate=120

	--COPlatency=10
	--disableTouchDownFeedback=false
	--model.simulationSubTimesteps=1 -- has to be 1 for unknown reason
	--model.penaltyForceStiffness=20000
	--model.penaltyForceDamp=2000
	--model.k_p_ID=250
	--model.k_d_ID=25
	--model.k_p_PD=200
	--model.k_d_PD=15
	--model.k_ID_torque_scale=1
	----model.k_p_PD=10
	----model.k_d_PD=5
	--model.k_p_JTfoot=500
	--model.k_d_JTfoot=50
	--model.k_scale_active_pd.knee={0.5,0.5,1}
	--model.k_scale_id.knee={1,1,1}
	--model.k_scale_id.ankle={1,1,1}
	--model.k_scale_id.toes={1,1,1}
	--model.k_scale_id.shoulder={1,1,1}
	--model.initialHeight=0.0
end

--TODO:YSLEE
useCases.gait_muscle.segmentations=
{
	gait_muscle={
		--firstFrames={1*4,2*40,37*4,43*4,48*4,62*4,80*4,98*4,115*4,132*4,149*4,168*4},
		----                 b  r    d   L   R    L   R   L   R    L
		--names={          'stand','r','rl','l1', 'R1',  'L','R2','L2','R3'},
		--swingL={            0,    1,  0  ,  0 ,   1 ,   0,  1,  0,   1  },
		--swingR={            0,    0,  0  ,  1 ,   0 ,   1,  0,  1,   0  },
		firstFrames={1,   10,  80,  157,  227,  301,  373,  447, },
		--        (blank)    L    R    L     R     L     (blank)
		names={             'l', 'r', 'L1', 'R1', 'L2',  },
		swingL={             0,   1,   0,    1,    0,    },
		swingR={             1,   0,   1,    0,    1,    },
		footRefL= "convertFromSwingL",
		footRefR= "convertFromSwingR",
		usePositionControl=false,
	},
}
useCases.gait_muscle.graphParam={
	gait_muscle={
		--seg={          'stand','r','rl','l1','R1','L', 'R',},
		--num_key={         3,    3,  2,    3,  4  , 4,   4 , },
		--key_first={       0,    0, 'r',   0,  0  , 0,   0 , },
		--key_last={       'r', 'rl','l1','R1','L','R', 'L', },
		seg={            'l',  'r',  'L1', 'R1','L'},
		num_key={         3,    3,    3  ,  4,  4},
		key_first={       0,    0,    0  ,  0,  0},
		key_last={       'r', 'L1',  'R1', 'L', 'R1'},

	},
}
useCases.gait_muscle.graph={
	--{
		--"addInterpolatedSegment",
		--grpName="turn",
		--name="R",
		--seg0={"turn", "R2"},
		--seg1={"turn", "R1"},
		--startWeight=0, endWeight=1
	--},
	--{"connectMulti", "turn", "stand", "r", "rl", "l1",'R1', 'L', 'R', 'L'},
	--{"initialSegment", "turn", "stand"}
	{
		"addInterpolatedSegment",
		grpName="gait_muscle",
		name="L",
		seg0={"gait_muscle", "L2"},
		seg1={"gait_muscle", "L1"},
		startWeight=0, endWeight=1
	},
	{"connectMulti", "gait_muscle", "l", "r", "L1", "R1", "L", "R1"},
	{"initialSegment", "gait_muscle", "r"}
}
useCases.gait_muscle.segNames={
	"l", "r", "L1", 'R1','L',
}
--TODO:YSLEE

do 
	useCases.gait_muscle.controlParam={
		['useCases,gait_muscle,COMobjWeight']=0, 
		['useCases,gait_muscle,conservativeW']=1, 
		--['useCases,gait_muscle,contactMargin']=0.01, 
		['useCases,gait_muscle,dotMomentumScale']=0.3, 
		['useCases,gait_muscle,excludeRoot']=true, 
		['useCases,gait_muscle,headControlWeight']=0, 
		['useCases,gait_muscle,k_d_HEAD']=14, 
		['useCases,gait_muscle,k_p_HEAD']=0, 
		['useCases,gait_muscle,k_d_EE']=24, 
		['useCases,gait_muscle,k_d_momentum']=10, 
		['useCases,gait_muscle,k_p_EE']=120, 

		--['useCases,gait_muscle,maxPenetratingVel']=0, 
		['useCases,gait_muscle,momentumThr']=50, 
		['useCases,gait_muscle,noComvelDependentFootAdjustment']=true, 
		['useCases,gait_muscle,noIntersectionPrevenction']=true, 
		['useCases,gait_muscle,numericalDerivDmot']=true, 
		['useCases,gait_muscle,perClassContactMargin']=1, 
		['useCases,gait_muscle,turnGain']=10, 
		['useCases,gait_muscle,velMarginOffset']=0, 

		['useCases,gait_muscle,actuationType']      = useCases.gait_muscle.actuationType,
		['useCases,gait_muscle,k_p_ID']             = useCases.gait_muscle.k_p_ID,
		['useCases,gait_muscle,k_d_ID']             = useCases.gait_muscle.k_d_ID,
		['useCases,gait_muscle,ddqObjWeight']       = useCases.gait_muscle.ddqObjWeight,
		['useCases,gait_muscle,tauObjWeight']       = useCases.gait_muscle.tauObjWeight,
		['useCases,gait_muscle,ftObjWeight']        = useCases.gait_muscle.ftObjWeight,
		['useCases,gait_muscle,aObjWeight']         = useCases.gait_muscle.aObjWeight,
		['useCases,gait_muscle,lambdaObjWeight']    = useCases.gait_muscle.lambdaObjWeight,
		['useCases,gait_muscle,EEobjWeight']        = useCases.gait_muscle.EEobjWeight,
		['useCases,gait_muscle,EEobjWeightAngular'] = useCases.gait_muscle.EEobjWeightAngular,
		['useCases,gait_muscle,momentumWeight']     = useCases.gait_muscle.momentumWeight,
		['useCases,gait_muscle,tauMax']             = useCases.gait_muscle.tauMax,
		['useCases,gait_muscle,ftMax']              = useCases.gait_muscle.ftMax,
	}

	local function accumulate(cp_mod)
		local useCase=useCases.gait_muscle
		useCases.accumulate(useCase, cp_mod)
	end

	useCases.gait_muscle.noCOMjoint=true
	useCases.gait_muscle.spprtImpFromImp=true
	function modifySwingFoot(key, id, mod,inc,postfix)
		postfix=postfix or 'MocapMod'
		local useCase=useCases.walk3
		local c='map,'..key..',swingFoot'..postfix..','..id
		if inc then
			useCase.controlParam[c]=useCase.controlParam[c]+mod
		else
			useCase.controlParam[c]=mod
		end
	end

	--useCases.gait_muscle.useBulletColdet=true
	useCases.gait_muscle.useBulletColdet=false

	accumulate({
		--['keyframe,0,footRmod,gait_muscle,l,y']  = 0.,
		--['keyframe,1,footRmod,gait_muscle,l,y']  = 0.05,
		['keyframe,0,footLmod,gait_muscle,r,y']  = 0.0,
		['keyframe,1,footLmod,gait_muscle,r,y']  = 0.2,
		['keyframe,0,footRmod,gait_muscle,L1,y'] = 0.0,
		['keyframe,1,footRmod,gait_muscle,L1,y'] = 0.2,
		['map,0,swingFootMod,gait_muscle,y']     = 0.1,
		['map,1,swingFootMod,gait_muscle,y']     = 0.2,
		['map,2,swingFootMod,gait_muscle,y']     = 0.1,

		--['keyframe,0,footLmod,gait_muscle,l,y']  = 0.,
		--['keyframe,1,footLmod,gait_muscle,l,y']  = 0.,
		['keyframe,0,footRmod,gait_muscle,r,y']  = 0.,
		['keyframe,1,footRmod,gait_muscle,r,y']  = -.1,
		['keyframe,0,footLmod,gait_muscle,L1,y'] = 0.,
		['keyframe,1,footLmod,gait_muscle,L1,y'] = -.1,
		['map,0,spprtFootMod,gait_muscle,y']     = 0.,
		['map,1,spprtFootMod,gait_muscle,y']     = 0.,
		['map,2,spprtFootMod,gait_muscle,y']     = 0.,
	})

	useCases.unmapControlParam(useCases.gait_muscle)

end


